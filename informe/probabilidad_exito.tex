En secciones anteriores hablamos de la probabilidad de éxito pero aún no dimos
una definición formal para la misma. Intuitivamente, la probablidad se computa
considerando todos los caminos en la estructura de $\SessionType$ que llevan a
un estado $\Done$. Formalmente:

\begin{definition}[Probabilidad de éxito]
  \label{def:pr}
	La \emph{probabilidad de éxito} de un tipo sesión $\SessionType$,
	denotada como $\psfun\SessionType$, se encuentra definida por
	las siguientes ecuaciones:
  \[
    \begin{array}{r@{~}c@{~}l}
      \psfun\Idle & = & 0 \\
      \psfun\Done & = & 1 \\
    \end{array}
    \quad
    \begin{array}{r@{~}c@{~}l}
      \psfun{\In\Type\SessionType} & = & \psfun\SessionType \\
      \psfun{\Out\Type\SessionType} & = & \psfun\SessionType \\
    \end{array}
    \quad
    \begin{array}{r@{~}c@{~}l}
      \psfun{\BinaryPBranch\SessionTypeT\SessionTypeS} & = & p\psfun\SessionTypeT + (1-p)\psfun\SessionTypeS \\
      \psfun{\BinaryPChoice\SessionTypeT\SessionTypeS} & = & p\psfun\SessionTypeT + (1-p)\psfun\SessionTypeS \\
    \end{array}
  \]
\end{definition}

Para un tipo sesión $\SessionType$ \emph{finito}, la Definición \ref{def:pr}
describe un algoritmo recursivo para el cómputo de $\psfun\SessionType$. Cuando
$\SessionType$ es infinito (un protocolo recursivo) deja de ser tan obvio. Para
obtener un algoritmo que funcione en el caso general, interpretamos
$\psfun\SessionType$ como una \emph{variable aleatoria}. La Definición
\ref{def:pr} nos permite derivar un \emph{sistema finito de ecuaciones}
relacionando tales variables. El lado derecho de cada ecuación para
$\psfun\SessionType$ está expresada en términos de variables aleatorias que
corresponden a los nodos hijos en el árbol descrito por $\SessionType$. Como
$\SessionType$ tiene una cantidad finita de sub-árboles, obtenemos un número
finito de ecuaciones.

Luego, observamos que cada tipo sesión $\SessionType$ corresponde a una Cadena
de Markov en Tiempo Discreto (Discrete-Time Markov Chain, DTMC)~\todo{cita a
paper DTMC} cuyo espacio de estados es $\trees\SessionType = \mathset{S_1,
\dots, S_n}$ y tal que la probabilidad $p_{ij}$ de transicionar de un estado
$S_i$ al estado $S_j$ está dada por
\[
  p_{ij} \eqdef
  \begin{cases}
    p & \text{si $S_i \tred[p] S_j$}
    \\
    0 & \text{caso contrario}
  \end{cases}
\]
\label{pg:regreach}

La regularidad y alcanzabilidad implican que la DTMC obtenida por el tipo
sesión $\SessionType$ tiene un número de estados finito y es absorbente. Esto
significa siempre es posible alcanzar un \emph{estado absorbente} ($\Done$ ó
$\Idle$) desde cualquier \emph{estado transiente} (cualquier otro tipo sesión).
En cualquier DTMC absorbente con un número de estados finito, la probabilidad
de alcanzar un estado absorbente desde uno transiente puede ser computado
mediante la resolución de un sistema de ecuaciones para el cual se garantiza
una solución única \todo{~cite{KemenySnell76}}. La solución que se obtiene para
$\psfun\SessionType$ utilizando la Definición \ref{def:pr} es la que determina
la probabilidad de llegar a un estado $\Done$ desde $\SessionType$.

\section{Extendiendo decodificación para tipos sesión probabilísticos}

Cuando hablamos sobre la codificación de los tipos sesión, mencionamos
brevemente el uso de \texttt{rosetta} para decodificar los tipos generados por
\OCaml. Esta herramienta utiliza la gramática de tipos de \OCaml para parsear
las interfaces y aplicar la función inversa $\decfun\cdot$ a los tipos sesión
codificados. El resultado es un árbol de sintaxis abstracta que puede ser
utilizado para procesamientos o simplemente ser impreso bajo la sintaxis que
uno desee.

La extensión al cálculo de tipos sesión probabilísticos consistió de dos
partes: modificar la función inversa para considerar tipos probabilísticos y
constructores de terminación exitosa, y el cálculo de probabilidad de éxito
para tipos sesión cerrados $\ClosedSessionType$.

Lo primero consistió en modificar la decodificación de forma tal que se
contemplen las anotaciones de probabilidad en el árbol sintáctico final. Esto
requirió cambios únicamente en el modelado de tipos para recibir o enviar
elecciones. Las probabilidades en sí, que como vimos en la sección de
codificación representan su valor en el tipo, también debieron ser consideradas
al momento de representarlas en el árbol sintáctico. Ya que se asume las
expresiones a decodificar tipan en \OCaml, se transforman para conservar
únicamente su valor en un tipo \OI{int} o \OI{float} según el caso. Por último,
se creó la distinción entre los nodos $\Done$ y $\Idle$, indispensable para el
cálculo de probabilidad de éxito.

Lo segundo fue agregar el procesamiento necesario para computar la probabilidad
de éxito en los tipos sesión cerrados. Para ello, primero tomamos el árbol
sintáctico correspondiente al endpoint de tipo $\SessionType$ (el cual describe
la sesión cerrada) y lo transformamos a una matriz de adyacencia con las
probabilidades de transición $p_{ij}$ descritas anteriormente.

Esta matriz es dividida en submatrices que corresponden a las transiciones
entre estados transitorios y las que van de estados transitorios a absorbentes.
Con esta información es posible computar la matriz de absorción que contiene la
probabilidad con la que cada estado es absorbido a $\Done$ o $\Idle$.

\section{Ejemplos}

Vamos a seguir el ejemplo de subasta presentado en (prob analysis) \todo{citar
prob analysis} para ver cómo se decodifica su tipo y cómo se computa su
probabilidad de éxito al combinarlo con su dual.

Presentamos un programa que actúa como comprador y su dual, vendedor.

\AuctionBuyer

El comprador envía una oferta y espera la decisión del vendedor. En caso de
aceptarse la oferta, la sesión termina exitosamente. Si esta es rechazada; el
comprador recibe una contra-oferta y debe decidir si aceptarla o no. Si la
rechaza, el protocolo termina sin éxito; caso contrario se llama recursivamente
para repetir la secuencia.

Mediante \texttt{rosetta} obtenemos el siguiente tipo para \OI{ep}: $rec\
X.\Out\tint\BinaryPBranch[p]{\Done}{\In\tint\BinaryPChoice[\frac{2}{3}]{\Idle}{X}}$.
Una diferencia con respecto a los ejemplos anteriores es que al presentar una
recursión, la sesión hace referencia así misma mediante la variable de tipo $X$.

A continuación presentamos el programa vendedor:

\AuctionSeller

El tipo decodificado de \OI{ep} es $rec\
X.\In\tint\BinaryPChoice[\frac{1}{4}]{\Done}{\Out\tint\BinaryPBranch[q]{\Idle}{X}}$.
Además de ser el dual del endpoint utilizado por el comprador, podemos observar
tiene instanciada la probabilidad de elección que requiere su contraparte.

Finalmente, unimos ambos endpoints en un programa que ejecuta la subasta:

\TestAuction

Al unificar, el tipo de cada endpoint posee las probabilidades concretas para
cada elección; como ejemplo tomamos el tipo unificado para \OI{ep2} (el
endpoint comprador): $rec\
X.\Out\tint\BinaryPBranch[\frac{1}{4}]{\Done}{\In\tint\BinaryPChoice[\frac{2}{3}]{\Idle}{X}}$.
